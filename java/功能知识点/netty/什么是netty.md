### 前言

> 最近在面试，netty最近问的比较频繁， 阿里巴巴、苹果、微博、谷歌、Twitter、Facebook等都在使用 Netty 构建他们的现代网络服务。

同样，在一些中小企业甚至是创业型公司以及游戏行业，也大面积地使用 Netty，比如杀毒软件厂商 Avast使用它来服务递交病毒库，LeanCloud使用它来提供消息服务，甚至我们在看《权力的游戏》时，您看到的（如果您在美国看直播）也是通过 Netty 来直播的。当然我们也看到很多直播系统、网络游戏以及在线播客（比如喜马拉雅）都大面积 的使用了 Netty。

当然，不光是 Netty 项目本身，整个 Netty 社区也在探索更多更大的可能，所以我们在这里一起来聊一聊下面的几个话题吧：

### **Netty是什么**

Netty 是一款**异步**的**事件驱动**的**网络应用程序框架**，支持快速地开发可维护的高性能的面向协议的服务器和客户端。

#### **异步和同步**

**同步（Sync）**：所谓同步，就是线程发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作，而是等待可以调用。当可以调用之后，线程**自行进行调用**。**异步（Async）**：异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个**调用完成**后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。总结来说，同步和异步的区别大概有两个：

*   请求发出后，是否**可以返回**执行其他操作。
*   当可以进行调用时，**同步情况是发起调用的线程自己去调用并得到结果，异步情况是内核将调用动作完成，将结果返回给调用线程**。

#### **事件驱动**

一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu。也就是说，事件驱动就是有事件就处理，没时间就等待。

### **BIO、NIO和AIO的区别**

#### **事件分离器**

在IO读写时，把 IO请求 与 读写操作 分离调配进行，需要用到事件分离器。根据处理机制的不同，事件分离器又分为：同步的Reactor和异步的Proactor。**Reactor模型：**

*   应用程序在事件分离器注册 读就绪事件 和 读就绪事件处理器
*   事件分离器等待读就绪事件发生
*   读就绪事件发生，激活事件分离器，分离器调用 读就绪事件处理器（即：可以进行读操作了，开始读）
*   读事件处理器开始进行读操作，把读到的数据提供给程序使用

**Proactor模型：**

*   应用程序在事件分离器注册 读完成事件 和读完成事件处理器，并向操作系统发出异步读请求
*   事件分离器等待操作系统完成读取
*   在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成
*   事件分离器监听到 读完成事件 后，激活 读完成事件的处理器
*   读完成事件处理器 处理用户自定义缓冲区中的数据给应用程序使用

同步和异步的区别就在于 **读** 操作由谁完成：同步的Reactor是指程序发出读请求后，由分离器监听到可以进行读操作时（需要获得读操作条件）通知事件处理器进行读操作，异步的Proactor是指程序发出读请求后，操作系统立刻异步地进行读操作了，读完之后在通知分离器，分离器激活处理器直接取用已读到的数据。

**同步阻塞IO（BIO）：**在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！**同步非阻塞IO（NIO）:**在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。

**异步阻塞IO（AIO）：**此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！

**异步非阻塞IO:**在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。

### **Netty相关概念和基本架构**

Netty的核心组件包括以下几个部分：

*   BootStrap和ServerBootstrap BootStrap通常称为引导类，提供一个用于应用程序网络层配置的容器。
*   Channel 底层网路传输API必须提供给应用I/O操作的接口，如读、写、连接、绑定等。它结构类似一个“Socket”。它有很多类似于socket的函数：bind、close、config、connect、isActive、isOpen、isWritable、read、write等等。
*   ChannelHandler Handle称之为处理器，支持很多协议，提供用于数据处理的容器。常用的一个接口是ChannelInboundHandler，这个类型可以处理入站事件(即外部应用连接到本应用的事件)；反之有ChannelOutboundHandler接口，处理出站事件。业务逻辑经常在一个或多个ChannelInboundHandler中操作。
*   ChannelPipeline Netty的数据处理流程其实是一种责任链和拦截过滤器模式，ChannelPipeline 提供了一个链容器，该链包含一个或多个ChannelHandler ，并提供了一个API用于管理沿着链入站和出站事件的流动。
*   EventLoop EventLoop 用于处理 Channel 的 I/O操作。一个EventLoop可以处理多个Channel事件。而EventLoopGroup是一个Group，可以包括多个EventLoop。
*   ChannelFuture Netty是一种异步I/O模型，一个操作可能无法立即返回结果，所以它提供了ChannelFuture类，可以通过addListener添加监听器，操作完成时可以作出通知。

Netty的基本架构如下图所示:

![image](https://upload-images.jianshu.io/upload_images/4614633-1870fdf97c15b68a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
